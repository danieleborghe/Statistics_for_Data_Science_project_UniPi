# MAIN #
# === Setup iniziale ===
source("install_dependencies.R")
source("load_data.R")
source("conformal_predictors.R")     # contiene train_svm_model, compute_svm_scores, ecc.
source("evaluation_utils.R")         # contiene evaluate_intervals, evaluate_fsc, evaluate_ssc

# === Caricamento dati ===
dataset_path <- "C:/Users/PC/Desktop/STATS/Iris dataset.csv"
data_split <- load_and_split_data(dataset_path)
train_data <- data_split$train
calib_data <- data_split$calib
test_data  <- data_split$test
Y_test     <- test_data$Petal.Length
alpha <- 0.1

# === 1. SVM con residui assoluti ===
svm_model <- train_svm_model(train_data)
residuals_calib <- compute_svm_scores(svm_model, calib_data, mode = "residuals")
residual_model <- train_uncertainty_model(residuals_calib,
                                          calib_data[, -which(names(calib_data) == "Petal.Length")])
u_hat_calib <- predict(residual_model, newdata = calib_data)
q_resid <- compute_conformal_quantile_svm(residuals_calib, u_hat_calib, alpha = alpha)

# Costruzione intervalli su test
intervals_resid <- build_svm_intervals(svm_model, residual_model, test_data, q_resid)
eval_resid <- evaluate_intervals(Y_test, intervals_resid$lower, intervals_resid$upper, label = "SVM residui")

# Grafici
plot_svm_intervals(Y_test, intervals_resid$lower, intervals_resid$upper,
                   intervals_resid$midpoint, "Intervalli conformali – SVM residui")
plot_adaptivity(intervals_resid$lower, intervals_resid$upper, Y_test, "SVM residui")

evaluate_fsc(test_data, eval_resid$covered)
fsc_cov_resid <- evaluate_fsc(test_data, eval_resid$covered)
plot_fsc(fsc_cov_resid, "FSC – SVM residui")

evaluate_ssc(eval_resid$width, eval_resid$covered)
ssc_cov_resid <- evaluate_ssc(eval_resid$width, eval_resid$covered)
plot_ssc(ssc_cov_resid, "SSC – SVM residui")
# === 2. SVM con stima deviazione standard dei residui ===
fhat_calib <- predict(svm_model, newdata = calib_data)
residuals_sq <- (calib_data$Petal.Length - fhat_calib)^2
stddev_model <- train_uncertainty_model(residuals_sq,
                                        calib_data[, -which(names(calib_data) == "Petal.Length")])
sigma_hat_calib <- sqrt(pmax(predict(stddev_model, newdata = calib_data), 0))
scores_stddev <- abs(calib_data$Petal.Length - fhat_calib) / sigma_hat_calib
q_stddev <- quantile(scores_stddev, probs = 1 - alpha, type = 1)

# Costruzione intervalli
fhat_test <- predict(svm_model, newdata = test_data)
sigma_hat_test <- sqrt(pmax(predict(stddev_model, newdata = test_data), 0))
lower_stddev <- fhat_test - q_stddev * sigma_hat_test
upper_stddev <- fhat_test + q_stddev * sigma_hat_test

# Valutazione
eval_stddev <- evaluate_intervals(Y_test, lower_stddev, upper_stddev, label = "SVM StdDev")
plot_svm_intervals(Y_test, lower_stddev, upper_stddev, fhat_test,
                   "Intervalli conformali – SVM std dev")
plot_adaptivity(lower_stddev, upper_stddev, Y_test, "SVM std dev")
covered_stddev <- (Y_test >= lower_stddev) & (Y_test <= upper_stddev)
width_stddev <- upper_stddev - lower_stddev

evaluate_fsc(test_data, covered_stddev)
fsc_cov_stddev <- evaluate_fsc(test_data, covered_stddev)
plot_fsc(fsc_cov_stddev, "FSC – SVM Std Dev")

evaluate_ssc(width_stddev, covered_stddev)
ssc_cov_stddev <- evaluate_ssc(width_stddev, covered_stddev)
plot_ssc(ssc_cov_stddev, "SSC – SVM Std Dev")

